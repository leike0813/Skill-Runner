{% extends "base.html" %}
{% block content %}
<section class="card">
    <h2 style="margin-top: 0;">Run Observation: <code>{{ request_id }}</code></h2>
    <div class="row">
        <div style="flex: 1 1 200px;"><strong>Status:</strong> <span id="run-status">loading</span></div>
        <div style="flex: 1 1 200px;"><strong>Pending ID:</strong> <span id="pending-id">-</span></div>
        <div style="flex: 1 1 200px;"><strong>Source:</strong> <span id="run-source">{{ run_source }}</span></div>
        <div style="flex: 1 1 200px;"><strong>Cursor:</strong> <span id="run-cursor">0</span></div>
        <div style="flex: 1 1 220px;">
            <a class="btn secondary" href="/runs">Runs</a>
        </div>
    </div>
</section>

<section class="card" style="margin-top: 16px;">
    <h3 style="margin-top: 0;">Conversation</h3>
    <div id="chat-panel" class="chat-panel"></div>

    <div id="thinking-card" class="thinking-card hidden" role="status" aria-live="polite">
        <div class="thinking-dots" aria-hidden="true">
            <span></span><span></span><span></span>
        </div>
        <div>
            <div class="thinking-title">Agent is thinking</div>
            <div class="thinking-desc">Running inference and preparing the next response...</div>
        </div>
    </div>

    <div id="final-summary-card" class="prompt-card hidden" role="status" aria-live="polite">
        <div style="font-weight: 700; margin-bottom: 6px;">Final Summary</div>
        <div id="final-summary-text"></div>
    </div>

    <div id="prompt-card" class="prompt-card hidden">
        <div style="font-weight: 700; margin-bottom: 6px;">Pending Input Request</div>
        <div id="prompt-card-text"></div>
        <div class="prompt-meta">
            <span>interaction_id: <code id="prompt-card-id">-</code></span>
            <span>kind: <code id="prompt-card-kind">-</code></span>
        </div>
        <div id="prompt-card-options" class="prompt-list hidden"></div>
        <div id="prompt-card-required" class="prompt-list hidden"></div>
    </div>

    <form id="reply-form" class="reply-box">
        <input type="hidden" id="interaction-id" value="">
        <textarea id="reply-text" rows="3" placeholder="Reply to agent..." disabled></textarea>
        <div class="reply-actions">
            <button class="btn" id="reply-submit" type="submit" disabled>Send Reply</button>
            <span class="muted" id="reply-shortcut-hint">Ctrl+Enter / Cmd+Enter to send</span>
        </div>
    </form>
</section>

<section class="card" style="margin-top: 16px;">
    <div class="reply-actions" style="justify-content: space-between;">
        <h3 style="margin: 0;">Run File Tree</h3>
        <button class="btn secondary" id="file-tree-toggle" type="button">Show Files</button>
    </div>
    <div id="file-tree-section" class="hidden" style="margin-top: 10px;">
        <div class="file-tree-layout">
            <div id="file-tree-panel" class="chat-panel file-panel"></div>
            <div id="file-preview-panel" class="chat-panel file-panel preview-panel"></div>
        </div>
    </div>
</section>

<style>
    .chat-panel {
        height: 420px;
        overflow: auto;
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 14px;
        background: linear-gradient(180deg, #f9fbfa 0%, #f4f8f6 100%);
    }
    .chat-row {
        display: flex;
        margin-bottom: 10px;
    }
    .chat-row.agent {
        justify-content: flex-start;
    }
    .chat-row.user {
        justify-content: flex-end;
    }
    .chat-bubble {
        max-width: min(78%, 760px);
        border-radius: 14px;
        padding: 10px 12px;
        white-space: pre-wrap;
        line-height: 1.5;
        border: 1px solid var(--line);
        box-shadow: 0 4px 14px rgba(20, 100, 59, 0.08);
    }
    .chat-bubble.agent {
        background: #ffffff;
        color: var(--fg);
    }
    .chat-bubble.user {
        background: #dff4e8;
        color: #0e3b25;
        border-color: #b8e1c8;
    }
    .chat-role {
        display: block;
        font-size: 12px;
        font-weight: 700;
        margin-bottom: 6px;
        opacity: 0.72;
        letter-spacing: 0.02em;
    }
    .prompt-card {
        margin-top: 12px;
        border: 1px solid #c7dece;
        border-radius: 12px;
        padding: 10px 12px;
        background: #edf7f1;
    }
    .prompt-card.hidden {
        display: none;
    }
    .thinking-card {
        margin-top: 12px;
        border: 1px solid #bed8cb;
        border-radius: 12px;
        padding: 10px 12px;
        background: #eff8f3;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .thinking-title {
        font-size: 13px;
        font-weight: 700;
        color: #1e5138;
    }
    .thinking-desc {
        font-size: 12px;
        color: #55776a;
    }
    .thinking-dots {
        display: inline-flex;
        align-items: center;
        gap: 5px;
    }
    .thinking-dots span {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #2f7257;
        opacity: 0.25;
        animation: thinkingPulse 1.2s ease-in-out infinite;
    }
    .thinking-dots span:nth-child(2) {
        animation-delay: 0.2s;
    }
    .thinking-dots span:nth-child(3) {
        animation-delay: 0.4s;
    }
    @keyframes thinkingPulse {
        0%, 80%, 100% {
            transform: translateY(0);
            opacity: 0.25;
        }
        40% {
            transform: translateY(-2px);
            opacity: 0.9;
        }
    }
    .hidden {
        display: none;
    }
    .prompt-meta {
        margin-top: 8px;
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
        font-size: 12px;
        color: var(--muted);
    }
    .prompt-list {
        margin-top: 8px;
        font-size: 13px;
        color: var(--muted);
    }
    .prompt-list.hidden {
        display: none;
    }
    .reply-box {
        margin-top: 12px;
        border-top: 1px solid var(--line);
        padding-top: 12px;
    }
    .reply-box textarea {
        width: 100%;
        border-radius: 10px;
        border: 1px solid var(--line);
        padding: 10px;
        background: #fff;
        font: inherit;
    }
    .reply-actions {
        margin-top: 8px;
        display: flex;
        align-items: center;
        gap: 12px;
    }
    .file-entry {
        margin-bottom: 6px;
        font-size: 13px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .file-entry button {
        border: 0;
        background: none;
        color: var(--accent);
        text-align: left;
        cursor: pointer;
        padding: 0;
        font: inherit;
    }
    .file-tree-layout {
        display: grid;
        grid-template-columns: minmax(260px, 360px) minmax(0, 1fr);
        gap: 12px;
    }
    .file-panel {
        height: 320px;
        min-width: 0;
    }
    .preview-panel {
        background: #fff;
        overflow: hidden;
        padding: 10px 12px;
    }
    .preview-title {
        margin-bottom: 8px;
        color: #374151;
        font-size: 13px;
        font-weight: 700;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .preview-meta {
        margin-bottom: 8px;
        color: var(--muted);
        font-size: 12px;
    }
    .preview-content {
        margin: 0;
        white-space: pre;
        overflow: auto;
        font-size: 12px;
        line-height: 1.45;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    .preview-empty {
        color: var(--muted);
        font-size: 13px;
    }
    @media (max-width: 960px) {
        .file-tree-layout {
            grid-template-columns: 1fr;
        }
    }
</style>

<script>
(() => {
    const requestId = "{{ request_id }}";
    const runSource = "{{ run_source }}";
    const statusEl = document.getElementById("run-status");
    const pendingIdEl = document.getElementById("pending-id");
    const cursorEl = document.getElementById("run-cursor");
    const chatEl = document.getElementById("chat-panel");
    const replyForm = document.getElementById("reply-form");
    const interactionIdEl = document.getElementById("interaction-id");
    const replyTextEl = document.getElementById("reply-text");
    const replySubmitEl = document.getElementById("reply-submit");
    const thinkingCardEl = document.getElementById("thinking-card");
    const finalSummaryCardEl = document.getElementById("final-summary-card");
    const finalSummaryTextEl = document.getElementById("final-summary-text");
    const promptCardEl = document.getElementById("prompt-card");
    const promptTextEl = document.getElementById("prompt-card-text");
    const promptIdEl = document.getElementById("prompt-card-id");
    const promptKindEl = document.getElementById("prompt-card-kind");
    const promptOptionsEl = document.getElementById("prompt-card-options");
    const promptRequiredEl = document.getElementById("prompt-card-required");
    const fileTreeToggleEl = document.getElementById("file-tree-toggle");
    const fileTreeSectionEl = document.getElementById("file-tree-section");
    const fileTreePanelEl = document.getElementById("file-tree-panel");
    const filePreviewPanelEl = document.getElementById("file-preview-panel");

    let cursor = 0;
    let stream = null;
    let reconnectTimer = null;
    let reconnectAttempts = 0;
    let currentStatus = "loading";
    let finalSummaryLoaded = false;
    let finalSummaryAttempts = 0;
    let finalSummaryRetryTimer = null;
    let historyLoaded = false;
    let fileTreeLoaded = false;
    let fileTreeExpanded = false;
    const renderedChatKeys = new Set();
    const renderedPromptKeys = new Set();
    const DEFAULT_INTERACTIVE_REPLY_TIMEOUT_SEC = 1200;
    const WATCHDOG_RETRY_INTERVAL_MS = 2000;
    const WATCHDOG_RETRY_WINDOW_MS = 30000;
    let interactiveAutoReplyEnabled = false;
    let interactiveReplyTimeoutSec = DEFAULT_INTERACTIVE_REPLY_TIMEOUT_SEC;
    let waitingUserWatchdogTimer = null;
    let waitingUserWatchdogStartAt = 0;
    let waitingUserWatchdogInFlight = false;

    function apiUrl(path) {
        const separator = path.includes("?") ? "&" : "?";
        return `${path}${separator}source=${encodeURIComponent(runSource)}`;
    }

    function safeText(value) {
        return typeof value === "string" ? value : "";
    }

    function normalizeList(raw) {
        if (!Array.isArray(raw)) return [];
        const values = [];
        for (const item of raw) {
            const text = safeText(item).trim();
            if (text) values.push(text);
        }
        return values;
    }

    function updateCursor(next) {
        if (typeof next !== "number" || !Number.isFinite(next)) return;
        if (next <= cursor) return;
        cursor = next;
        cursorEl.textContent = String(cursor);
    }

    function clearWaitingUserWatchdog() {
        if (waitingUserWatchdogTimer) {
            clearTimeout(waitingUserWatchdogTimer);
            waitingUserWatchdogTimer = null;
        }
        waitingUserWatchdogStartAt = 0;
        waitingUserWatchdogInFlight = false;
    }

    function updateInteractiveAutoReplyConfig(payload) {
        if (!payload || typeof payload !== "object") return;
        if (typeof payload.interactive_auto_reply === "boolean") {
            interactiveAutoReplyEnabled = payload.interactive_auto_reply;
        }
        if (
            typeof payload.interactive_reply_timeout_sec === "number"
            && Number.isFinite(payload.interactive_reply_timeout_sec)
            && payload.interactive_reply_timeout_sec > 0
        ) {
            interactiveReplyTimeoutSec = Math.floor(payload.interactive_reply_timeout_sec);
        } else if (typeof payload.interactive_reply_timeout_sec === "number") {
            interactiveReplyTimeoutSec = DEFAULT_INTERACTIVE_REPLY_TIMEOUT_SEC;
        }
    }

    async function executeWaitingUserWatchdogTick() {
        if (waitingUserWatchdogInFlight) return;
        if (currentStatus !== "waiting_user" || isTerminal(currentStatus)) {
            clearWaitingUserWatchdog();
            return;
        }
        waitingUserWatchdogInFlight = true;
        try {
            await refreshState();
            if (currentStatus !== "waiting_user") {
                clearWaitingUserWatchdog();
                if (!stream && !isTerminal(currentStatus)) {
                    await startStream();
                }
                return;
            }
        } finally {
            waitingUserWatchdogInFlight = false;
        }
        const elapsed = Date.now() - waitingUserWatchdogStartAt;
        if (elapsed >= WATCHDOG_RETRY_WINDOW_MS) {
            clearWaitingUserWatchdog();
            return;
        }
        waitingUserWatchdogTimer = setTimeout(executeWaitingUserWatchdogTick, WATCHDOG_RETRY_INTERVAL_MS);
    }

    function maybeStartWaitingUserWatchdog() {
        if (!interactiveAutoReplyEnabled) {
            clearWaitingUserWatchdog();
            return;
        }
        if (currentStatus !== "waiting_user" || isTerminal(currentStatus)) {
            clearWaitingUserWatchdog();
            return;
        }
        if (waitingUserWatchdogTimer || waitingUserWatchdogStartAt > 0) return;
        waitingUserWatchdogStartAt = Date.now();
        const initialDelayMs = Math.max(1, interactiveReplyTimeoutSec) * 1000;
        waitingUserWatchdogTimer = setTimeout(executeWaitingUserWatchdogTick, initialDelayMs);
    }

    function isTerminal(status) {
        return ["succeeded", "failed", "canceled"].includes(status);
    }

    function setReplyEnabled(enabled) {
        replyTextEl.disabled = !enabled;
        replySubmitEl.disabled = !enabled;
    }

    function updateThinkingCard(status) {
        if (!thinkingCardEl) return;
        const show = safeText(status).trim() === "running";
        thinkingCardEl.classList.toggle("hidden", !show);
    }

    function appendChatBubble(role, text, key) {
        const normalizedText = safeText(text).trim();
        if (!normalizedText) return;
        if (key && renderedChatKeys.has(key)) return;
        if (key) renderedChatKeys.add(key);
        const row = document.createElement("div");
        row.className = `chat-row ${role}`;

        const bubble = document.createElement("div");
        bubble.className = `chat-bubble ${role}`;

        const roleEl = document.createElement("span");
        roleEl.className = "chat-role";
        roleEl.textContent = role === "user" ? "You" : "Agent";
        bubble.appendChild(roleEl);

        const content = document.createElement("div");
        content.textContent = normalizedText;
        bubble.appendChild(content);

        row.appendChild(bubble);
        chatEl.appendChild(row);
        chatEl.scrollTop = chatEl.scrollHeight;
    }

    function clearPromptCard() {
        promptCardEl.classList.add("hidden");
        promptTextEl.textContent = "";
        promptIdEl.textContent = "-";
        promptKindEl.textContent = "-";
        promptOptionsEl.textContent = "";
        promptRequiredEl.textContent = "";
        promptOptionsEl.classList.add("hidden");
        promptRequiredEl.classList.add("hidden");
        interactionIdEl.value = "";
        pendingIdEl.textContent = "-";
    }

    function clearFinalSummaryCard() {
        if (!finalSummaryCardEl || !finalSummaryTextEl) return;
        finalSummaryCardEl.classList.add("hidden");
        finalSummaryTextEl.textContent = "";
        finalSummaryLoaded = false;
        if (finalSummaryRetryTimer) {
            clearTimeout(finalSummaryRetryTimer);
            finalSummaryRetryTimer = null;
        }
    }

    function renderPromptCard(payload) {
        const prompt = safeText(payload.prompt).trim();
        const hint = safeText(payload.ui_hints?.hint || payload.hint).trim();
        const interactionId = Number(payload.interaction_id || 0);
        const kind = safeText(payload.kind).trim() || "open_text";
        const key = `${interactionId || 0}|${hint || prompt}`;
        renderedPromptKeys.add(key);

        promptCardEl.classList.remove("hidden");
        if (hint) {
            promptTextEl.textContent = hint;
            promptTextEl.classList.remove("hidden");
        } else {
            promptTextEl.textContent = "";
            promptTextEl.classList.add("hidden");
        }
        promptIdEl.textContent = interactionId > 0 ? String(interactionId) : "-";
        promptKindEl.textContent = kind;
        interactionIdEl.value = interactionId > 0 ? String(interactionId) : "";
        pendingIdEl.textContent = interactionId > 0 ? String(interactionId) : "-";

        const options = normalizeList(payload.options);
        if (options.length) {
            promptOptionsEl.classList.remove("hidden");
            promptOptionsEl.textContent = `options: ${options.join(" | ")}`;
        } else {
            promptOptionsEl.classList.add("hidden");
            promptOptionsEl.textContent = "";
        }

        const requiredFields = normalizeList(payload.required_fields);
        if (requiredFields.length) {
            promptRequiredEl.classList.remove("hidden");
            promptRequiredEl.textContent = `required_fields: ${requiredFields.join(", ")}`;
        } else {
            promptRequiredEl.classList.add("hidden");
            promptRequiredEl.textContent = "";
        }
    }

    function cleanYamlScalar(raw) {
        const value = safeText(raw).trim();
        if (!value) return "";
        if ((value.startsWith("'") && value.endsWith("'")) || (value.startsWith('"') && value.endsWith('"'))) {
            return value.slice(1, -1).trim();
        }
        return value;
    }

    function parseYamlScalar(block, key) {
        const regex = new RegExp(`^\\s*${key}:\\s*(.+)$`, "mi");
        const matched = block.match(regex);
        if (!matched) return "";
        return cleanYamlScalar(matched[1]);
    }

    function parseYamlList(block, key) {
        const lines = block.split(/\r?\n/);
        let startIndex = -1;
        let baseIndent = 0;
        for (let idx = 0; idx < lines.length; idx += 1) {
            const line = lines[idx];
            const matched = line.match(/^(\s*)([A-Za-z_][\w-]*):\s*$/);
            if (!matched) continue;
            if (matched[2] !== key) continue;
            startIndex = idx;
            baseIndent = matched[1].length;
            break;
        }
        if (startIndex < 0) {
            const inlineRaw = parseYamlScalar(block, key);
            if (!inlineRaw.startsWith("[") || !inlineRaw.endsWith("]")) return [];
            return inlineRaw
                .slice(1, -1)
                .split(",")
                .map((item) => cleanYamlScalar(item))
                .filter((item) => item);
        }
        const values = [];
        for (let idx = startIndex + 1; idx < lines.length; idx += 1) {
            const line = lines[idx];
            if (!line.trim()) continue;
            const indent = (line.match(/^(\s*)/) || ["", ""])[1].length;
            if (indent <= baseIndent) break;
            const itemMatched = line.match(/^\s*-\s*(.+)\s*$/);
            if (!itemMatched) continue;
            const value = cleanYamlScalar(itemMatched[1]);
            if (value) values.push(value);
        }
        return values;
    }

    function extractAskUserBlocks(text) {
        const source = safeText(text);
        const patterns = [
            /<ASK_USER_YAML>\s*([\s\S]*?)\s*<\/ASK_USER_YAML>/gim,
            /```(?:ask_user_yaml|ask-user-yaml)\s*([\s\S]*?)```/gim,
        ];
        const blocks = [];
        let stripped = source;
        for (const pattern of patterns) {
            const matches = Array.from(stripped.matchAll(pattern));
            if (!matches.length) continue;
            for (const matched of matches) {
                const body = safeText(matched[1]).trim();
                if (body) blocks.push(body);
            }
            stripped = stripped.replace(pattern, " ").trim();
        }
        return { blocks, stripped: stripped.trim() };
    }

    function parseAskUserYaml(block) {
        if (!block) return null;
        const scoped = block.includes("ask_user:") ? block.split(/ask_user:\s*/i)[1] || block : block;
        const prompt = parseYamlScalar(scoped, "prompt");
        const interactionRaw = parseYamlScalar(scoped, "interaction_id");
        const interactionId = interactionRaw ? Number(interactionRaw) : 0;
        const kind = parseYamlScalar(scoped, "kind") || "open_text";
        const hint = parseYamlScalar(scoped, "hint");
        const uiHints = {};
        if (hint) {
            uiHints.hint = hint;
        }
        return {
            interaction_id: Number.isFinite(interactionId) ? interactionId : 0,
            kind,
            prompt,
            options: parseYamlList(scoped, "options"),
            required_fields: parseYamlList(scoped, "required_fields"),
            ui_hints: uiHints,
            hint,
        };
    }

    function parseAskUserBlocks(blocks) {
        if (!Array.isArray(blocks) || !blocks.length) return null;
        for (const block of blocks) {
            const parsed = parseAskUserYaml(block);
            if (parsed) return parsed;
        }
        return null;
    }

    function parseResultStatusFromPreview(preview) {
        const raw = safeText(preview).trim();
        if (!raw || !raw.startsWith("{")) return "";
        try {
            const payload = JSON.parse(raw);
            const status = safeText(payload?.status).trim().toLowerCase();
            return status;
        } catch (_err) {
            return "";
        }
    }

    function buildFinalSummaryText(payload, resultStatus, preview, artifacts) {
        const normalizedStatus = safeText(resultStatus).trim().toLowerCase();
        if (normalizedStatus === "failed") {
            const message = safeText(payload.result_error_message).trim() || "Êú™Áü•ÈîôËØØ";
            return `‰ªªÂä°Â§±Ë¥•„ÄÇ\nerror_message: ${message}`;
        }
        if (normalizedStatus === "canceled") {
            const message = safeText(payload.result_error_message).trim() || "Áî®Êà∑ÂèñÊ∂à";
            return `‰ªªÂä°Â∑≤ÂèñÊ∂à„ÄÇ\nerror_message: ${message}`;
        }
        const hasResult = payload.has_result === true;
        const artifactLine = artifacts.length
            ? `\nartifacts: ${artifacts.slice(0, 8).join(", ")}`
            : "";
        const previewLine = preview ? `\nresult_preview: ${preview}` : "";
        return `‰ªªÂä°ÂÆåÊàê„ÄÇ${hasResult ? "\nÂ∑≤ÁîüÊàêÁªìÊûÑÂåñÁªìÊûú„ÄÇ" : ""}${artifactLine}${previewLine}`;
    }

    function applyPendingPrompt(payload) {
        const prompt = safeText(payload.prompt).trim();
        const hint = safeText(payload.ui_hints?.hint || payload.hint).trim();
        const interactionId = Number(payload.interaction_id || 0);
        const key = `${interactionId || 0}|${hint || prompt}`;
        renderPromptCard(payload);
        if (!renderedPromptKeys.has(key)) {
            renderedPromptKeys.add(key);
        }
        setReplyEnabled(interactionId > 0);
    }

    async function maybeAppendFinalSummary() {
        if (finalSummaryLoaded) return;
        if (!isTerminal(currentStatus)) return;
        finalSummaryAttempts += 1;
        try {
            const res = await fetch(apiUrl(`/api/runs/${requestId}/final-summary`));
            if (!res.ok) {
                scheduleFinalSummaryRetry();
                return;
            }
            const payload = await res.json();
            if (!payload) {
                scheduleFinalSummaryRetry();
                return;
            }
            let resultStatus = safeText(payload.result_status).trim().toLowerCase();
            if (!resultStatus) {
                resultStatus = parseResultStatusFromPreview(payload.result_preview);
            }
            const hasResult = payload.has_result === true;
            const hasArtifacts = payload.has_artifacts === true;
            if (!hasResult && !hasArtifacts) {
                scheduleFinalSummaryRetry();
                return;
            }
            const artifacts = Array.isArray(payload.artifacts) ? payload.artifacts : [];
            const preview = safeText(payload.result_preview).trim();
            if (finalSummaryCardEl && finalSummaryTextEl) {
                finalSummaryTextEl.textContent = buildFinalSummaryText(
                    payload,
                    resultStatus,
                    preview,
                    artifacts,
                );
                finalSummaryCardEl.classList.remove("hidden");
            }
            finalSummaryLoaded = true;
            if (finalSummaryRetryTimer) {
                clearTimeout(finalSummaryRetryTimer);
                finalSummaryRetryTimer = null;
            }
        } catch (_err) {
            scheduleFinalSummaryRetry();
        }
    }

    function scheduleFinalSummaryRetry() {
        if (finalSummaryLoaded) return;
        if (!isTerminal(currentStatus)) return;
        if (finalSummaryAttempts >= 6) return;
        if (finalSummaryRetryTimer) return;
        const delayMs = Math.min(2000, 400 * finalSummaryAttempts + 400);
        finalSummaryRetryTimer = setTimeout(async () => {
            finalSummaryRetryTimer = null;
            await maybeAppendFinalSummary();
        }, delayMs);
    }

    async function loadFileTree() {
        if (fileTreeLoaded) return;
        fileTreeLoaded = true;
        fileTreePanelEl.textContent = "Loading...";
        filePreviewPanelEl.innerHTML = '<div class="preview-empty">ÈÄâÊã©Â∑¶‰æßÊñá‰ª∂Êü•ÁúãÂÜÖÂÆπ„ÄÇ</div>';

        function renderFilePreview(relativePath, preview) {
            filePreviewPanelEl.textContent = "";
            const titleEl = document.createElement("div");
            titleEl.className = "preview-title";
            titleEl.textContent = relativePath;
            filePreviewPanelEl.appendChild(titleEl);

            const mode = safeText(preview?.mode);
            if (mode === "text") {
                const metaEl = document.createElement("div");
                metaEl.className = "preview-meta";
                metaEl.textContent = safeText(preview?.meta || "text");
                filePreviewPanelEl.appendChild(metaEl);
                const pre = document.createElement("pre");
                pre.className = "preview-content";
                pre.textContent = safeText(preview?.content);
                filePreviewPanelEl.appendChild(pre);
                return;
            }
            if (mode === "too_large") {
                const warn = document.createElement("div");
                warn.className = "preview-empty";
                warn.textContent = "Êñá‰ª∂ËøáÂ§ß‰∏çÂèØÈ¢ÑËßà";
                filePreviewPanelEl.appendChild(warn);
                const metaEl = document.createElement("div");
                metaEl.className = "preview-meta";
                metaEl.textContent = `${Number(preview?.size || 0)} bytes`;
                filePreviewPanelEl.appendChild(metaEl);
                return;
            }
            const unsupported = document.createElement("div");
            unsupported.className = "preview-empty";
            unsupported.textContent = "‰∏çÂèØÈ¢ÑËßà";
            filePreviewPanelEl.appendChild(unsupported);
            const metaEl = document.createElement("div");
            metaEl.className = "preview-meta";
            metaEl.textContent = safeText(preview?.meta || "Êó†‰ø°ÊÅØ");
            filePreviewPanelEl.appendChild(metaEl);
        }

        try {
            const res = await fetch(apiUrl(`/api/runs/${requestId}/bundle/entries`));
            if (!res.ok) {
                fileTreePanelEl.textContent = "File tree unavailable.";
                return;
            }
            const payload = await res.json();
            const entries = Array.isArray(payload.entries) ? payload.entries : [];
            fileTreePanelEl.textContent = "";
            if (!entries.length) {
                fileTreePanelEl.textContent = "No files.";
                return;
            }
            for (const entry of entries) {
                const row = document.createElement("div");
                row.className = "file-entry";
                const depth = Number(entry.depth || 0);
                row.style.paddingLeft = `${Math.max(0, depth) * 14}px`;
                const name = safeText(entry.name || entry.path);
                if (entry.is_dir) {
                    row.textContent = `üìÅ ${name}/`;
                } else {
                    const btn = document.createElement("button");
                    btn.type = "button";
                    btn.textContent = `üìÑ ${name}`;
                    btn.addEventListener("click", async () => {
                        const path = encodeURIComponent(safeText(entry.path));
                        const previewRes = await fetch(apiUrl(`/api/runs/${requestId}/bundle/file?path=${path}`));
                        if (!previewRes.ok) {
                            filePreviewPanelEl.innerHTML = `<div class="preview-empty">ËØªÂèñÂ§±Ë¥•: HTTP ${previewRes.status}</div>`;
                            return;
                        }
                        const previewPayload = await previewRes.json();
                        renderFilePreview(safeText(entry.path), previewPayload.preview || {});
                    });
                    row.appendChild(btn);
                }
                fileTreePanelEl.appendChild(row);
            }
        } catch (_err) {
            fileTreePanelEl.textContent = "File tree unavailable.";
        }
    }

    async function maybeLoadFileTreeOnTerminal() {
        if (!isTerminal(currentStatus)) return;
        if (!fileTreeExpanded) return;
        await loadFileTree();
    }

    async function refreshPending() {
        const res = await fetch(apiUrl(`/api/runs/${requestId}/pending`));
        if (!res.ok) {
            setReplyEnabled(false);
            clearPromptCard();
            return;
        }
        const payload = await res.json();
        const pending = payload && typeof payload.pending === "object" ? payload.pending : null;
        if (!pending) {
            setReplyEnabled(false);
            clearPromptCard();
            return;
        }
        applyPendingPrompt({
            interaction_id: Number(pending.interaction_id || 0),
            kind: safeText(pending.kind || "open_text"),
            prompt: safeText(pending.prompt),
            options: Array.isArray(pending.options) ? pending.options : [],
            required_fields: Array.isArray(pending.required_fields) ? pending.required_fields : [],
            ui_hints: pending.ui_hints && typeof pending.ui_hints === "object" ? pending.ui_hints : {},
        });
    }

    async function refreshState() {
        const res = await fetch(apiUrl(`/api/runs/${requestId}`));
        if (!res.ok) return;
        const payload = await res.json();
        updateInteractiveAutoReplyConfig(payload);
        currentStatus = safeText(payload.status || "unknown");
        statusEl.textContent = currentStatus;
        updateThinkingCard(currentStatus);
        pendingIdEl.textContent = payload.pending_interaction_id == null ? "-" : String(payload.pending_interaction_id);
        if (typeof payload.cursor === "number") updateCursor(payload.cursor);

        if (currentStatus === "waiting_user") {
            clearFinalSummaryCard();
            await refreshPending();
            maybeStartWaitingUserWatchdog();
        } else {
            clearWaitingUserWatchdog();
            setReplyEnabled(false);
            if (currentStatus !== "waiting_user") {
                clearPromptCard();
            }
            if (!isTerminal(currentStatus)) {
                clearFinalSummaryCard();
            }
        }
        if (isTerminal(currentStatus)) {
            clearWaitingUserWatchdog();
            if (stream) {
                stream.close();
                stream = null;
            }
            setReplyEnabled(false);
            clearPromptCard();
            await maybeAppendFinalSummary();
            await maybeLoadFileTreeOnTerminal();
        }
    }

    function scheduleReconnect() {
        if (reconnectTimer || currentStatus === "waiting_user" || isTerminal(currentStatus)) return;
        const delay = Math.min(1000 * (2 ** reconnectAttempts), 10000);
        reconnectAttempts += 1;
        reconnectTimer = setTimeout(async () => {
            reconnectTimer = null;
            await startStream();
            await refreshState();
        }, delay);
    }

    function handleConversationStateChanged(event) {
        const data = event && typeof event.data === "object" ? event.data : {};
        const nextStatus = safeText(data.to || currentStatus);
        if (!nextStatus) return;
        currentStatus = nextStatus;
        statusEl.textContent = currentStatus;
        updateThinkingCard(currentStatus);
        if (data.pending_interaction_id != null) {
            pendingIdEl.textContent = String(data.pending_interaction_id);
        }
        if (nextStatus === "waiting_user") {
            clearFinalSummaryCard();
            refreshPending().catch(() => {});
            maybeStartWaitingUserWatchdog();
            return;
        }
        clearWaitingUserWatchdog();
        if (!isTerminal(nextStatus)) {
            clearFinalSummaryCard();
        }
        if (isTerminal(nextStatus)) {
            setReplyEnabled(false);
            clearPromptCard();
            maybeAppendFinalSummary().catch(() => {});
            maybeLoadFileTreeOnTerminal().catch(() => {});
        }
    }

    function handleAssistantMessageFinal(event) {
        const text = safeText(event?.data?.text);
        const parsed = extractAskUserBlocks(text);
        const cleaned = parsed.stripped;
        if (cleaned) {
            appendChatBubble(
                "agent",
                cleaned,
                `assistant.message.final:${event.seq || 0}:${cleaned}`,
            );
        }
        const askPayload = parseAskUserBlocks(parsed.blocks);
        if (askPayload) {
            applyPendingPrompt(askPayload);
        }
    }

    function handleUserInputRequired(event) {
        const payload = {
            interaction_id: Number(event?.data?.interaction_id || 0),
            kind: safeText(event?.data?.kind || "open_text"),
            prompt: safeText(event?.data?.prompt),
            options: Array.isArray(event?.data?.options) ? event.data.options : [],
            required_fields: Array.isArray(event?.data?.required_fields) ? event.data.required_fields : [],
            ui_hints: event?.data?.ui_hints && typeof event.data.ui_hints === "object" ? event.data.ui_hints : {},
        };
        applyPendingPrompt(payload);
    }

    function handleChatEvent(event) {
        const type = safeText(event.type);
        if (typeof event.seq === "number") {
            updateCursor(event.seq);
        }
        if (!type) return;
        if (type === "conversation.state.changed") {
            handleConversationStateChanged(event);
            return;
        }
        if (type === "interaction.reply.accepted") {
            clearWaitingUserWatchdog();
            clearPromptCard();
            setReplyEnabled(false);
            const interactionId = Number(event?.data?.interaction_id || 0);
            const preview = safeText(event?.data?.response_preview).trim();
            if (preview) {
                appendChatBubble("user", preview, `user.reply:${interactionId}:${preview}`);
            } else {
                appendChatBubble("agent", "Â∑≤Êî∂Âà∞‰Ω†ÁöÑÂõûÂ§çÔºåÁªßÁª≠Â§ÑÁêÜ‰∏≠„ÄÇ", `reply.accepted:${event.seq || 0}`);
            }
            return;
        }
        if (type === "interaction.auto_decide.timeout") {
            clearWaitingUserWatchdog();
            clearPromptCard();
            setReplyEnabled(false);
            appendChatBubble("agent", "Á≠âÂæÖË∂ÖÊó∂ÔºåÁ≥ªÁªüÂ∑≤Ëá™Âä®ÂÜ≥Á≠ñÂπ∂ÁªßÁª≠ÊâßË°å„ÄÇ", `auto.timeout:${event.seq || 0}`);
            return;
        }
        if (type === "assistant.message.final") {
            handleAssistantMessageFinal(event);
            return;
        }
        if (type === "user.input.required") {
            handleUserInputRequired(event);
            return;
        }
        if (type === "conversation.completed") {
            maybeAppendFinalSummary().catch(() => {});
            maybeLoadFileTreeOnTerminal().catch(() => {});
            return;
        }
        if (type === "conversation.failed") {
            const code = safeText(event?.data?.error?.code || "");
            const message = code ? `‰ªªÂä°Â§±Ë¥•Ôºà${code}Ôºâ„ÄÇ` : "‰ªªÂä°Â§±Ë¥•„ÄÇ";
            appendChatBubble("agent", message, `conversation.failed:${event.seq || 0}:${code}`);
        }
    }

    async function loadHistory() {
        if (historyLoaded) return;
        historyLoaded = true;
        try {
            const res = await fetch(apiUrl(`/api/runs/${requestId}/events/history`));
            if (!res.ok) return;
            const payload = await res.json();
            const events = Array.isArray(payload.events) ? payload.events : [];
            for (const event of events) {
                handleChatEvent(event);
            }
        } catch (_err) {
            // Keep running even if history loading fails.
        }
    }

    async function startStream() {
        if (stream) {
            stream.close();
            stream = null;
        }
        stream = new EventSource(apiUrl(`/api/runs/${requestId}/events?cursor=${cursor}`));
        stream.addEventListener("snapshot", (evt) => {
            reconnectAttempts = 0;
            const payload = JSON.parse(evt.data || "{}");
            currentStatus = safeText(payload.status || currentStatus);
            statusEl.textContent = currentStatus;
            updateThinkingCard(currentStatus);
            if (payload.pending_interaction_id != null) {
                pendingIdEl.textContent = String(payload.pending_interaction_id);
            }
            if (typeof payload.cursor === "number") {
                updateCursor(payload.cursor);
            }
        });
        stream.addEventListener("chat_event", (evt) => {
            reconnectAttempts = 0;
            const payload = JSON.parse(evt.data || "{}");
            handleChatEvent(payload);
        });
        stream.addEventListener("error", () => {
            if (stream) {
                stream.close();
                stream = null;
            }
            scheduleReconnect();
        });
    }

    async function submitReply() {
        const interactionId = Number(interactionIdEl.value || "0");
        const text = safeText(replyTextEl.value).trim();
        if (!interactionId) return;
        clearWaitingUserWatchdog();
        const payload = {
            interaction_id: interactionId,
            response: { text },
        };
        const res = await fetch(apiUrl(`/api/runs/${requestId}/reply`), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
        });
        if (!res.ok) return;
        appendChatBubble("user", text || "(empty reply)", `user.reply:${interactionId}:${text}`);
        replyTextEl.value = "";
        clearPromptCard();
        setReplyEnabled(false);
        setTimeout(async () => {
            await startStream();
            await refreshState();
        }, 150);
    }

    replyForm.addEventListener("submit", async (evt) => {
        evt.preventDefault();
        await submitReply();
    });

    replyTextEl.addEventListener("keydown", async (evt) => {
        const isSendHotkey = (evt.ctrlKey || evt.metaKey) && evt.key === "Enter";
        if (!isSendHotkey) return;
        evt.preventDefault();
        if (replySubmitEl.disabled) return;
        await submitReply();
    });

    fileTreeToggleEl.addEventListener("click", async () => {
        fileTreeExpanded = !fileTreeExpanded;
        fileTreeSectionEl.classList.toggle("hidden", !fileTreeExpanded);
        fileTreeToggleEl.textContent = fileTreeExpanded ? "Hide Files" : "Show Files";
        if (fileTreeExpanded) {
            await maybeLoadFileTreeOnTerminal();
        }
    });

    (async () => {
        await loadHistory();
        await startStream();
        await refreshState();
    })();

    window.addEventListener("beforeunload", () => {
        clearWaitingUserWatchdog();
    });
})();
</script>
{% endblock %}
