<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Run Detail - {{ detail.request_id }}</title>
    <script src="https://unpkg.com/htmx.org@1.9.12"></script>
    <style>
        body { font-family: "Segoe UI", sans-serif; margin: 0; background: #f7f9fc; color: #1f2937; }
        .layout { max-width: 1280px; margin: 0 auto; padding: 20px; display: grid; gap: 16px; }
        .row { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 16px; }
        .row.three { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .card { background: #fff; border: 1px solid #e5e7eb; border-radius: 12px; padding: 14px; }
        .meta { color: #6b7280; font-size: 13px; margin-top: 6px; }
        .tree-line { font-size: 13px; line-height: 1.7; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .dir { color: #1d4ed8; }
        .file { color: #111827; }
        a { color: #0f766e; text-decoration: none; }
        a:hover { text-decoration: underline; }
        pre { margin: 0; white-space: pre-wrap; word-break: break-word; font-size: 12px; line-height: 1.5; }
        button { border: 0; border-radius: 8px; background: #0f766e; color: #fff; padding: 8px 12px; cursor: pointer; }
        button:hover { background: #0b5f58; }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        .danger { background: #b91c1c; }
        .danger:hover { background: #991b1b; }
        .pane-scroll { max-height: 340px; overflow: auto; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px; }
        .conversation-window { min-height: 220px; max-height: 380px; overflow: auto; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px; }
        .chat-item { margin: 0 0 10px; padding: 8px; border: 1px solid #e5e7eb; border-radius: 8px; background: #ffffff; }
        .chat-item.system { background: #f3f4f6; }
        .chat-item.user { background: #e8f5ec; }
        .stderr-window, .protocol-window, .raw-ref-window {
            max-height: 220px;
            overflow: auto;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px;
            font-size: 12px;
            font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .link-btn {
            border: 0;
            background: none;
            color: #0f766e;
            cursor: pointer;
            padding: 0;
            font-size: 12px;
            text-decoration: underline;
        }
        @media (max-width: 960px) {
            .row, .row.three { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
<div class="layout">
    <div class="card">
        <div><a href="/ui/runs">‚Üê Back to Runs</a></div>
        <h2 style="margin:8px 0 4px;">Request: {{ detail.request_id }}</h2>
        <div class="meta">run_id: {{ detail.run_id }}</div>
        <div class="meta">skill: {{ detail.skill_id or "-" }}</div>
        <div class="meta">engine: {{ detail.engine or "-" }}</div>
        <div class="meta">status: <span id="run-status">{{ detail.status }}</span></div>
        <div class="meta">updated_at: <span id="run-updated-at">{{ detail.updated_at or "-" }}</span></div>
        <div class="meta">pending_interaction_id: <span id="run-pending-id">{{ detail.pending_interaction_id if detail.pending_interaction_id is not none else "-" }}</span></div>
        <div class="meta">interaction_count: <span id="run-interaction-count">{{ detail.interaction_count }}</span></div>
    </div>

    <div class="row">
        <div class="card">
            <h3 style="margin:0 0 8px;">Run File Tree (Read-only)</h3>
            <div class="pane-scroll" id="run-file-tree-scroll">
                {% for entry in detail.entries %}
                <div class="tree-line" style="padding-left: {{ entry.depth * 16 }}px;">
                    {% if entry.is_dir %}
                    <span class="dir">üìÅ {{ entry.name }}/</span>
                    {% else %}
                    <span class="file">üìÑ</span>
                    <a
                        href="#"
                        hx-get="/ui/management/runs/{{ detail.request_id }}/view?path={{ entry.rel_path }}"
                        hx-target="#run-file-preview"
                        hx-swap="innerHTML"
                    >{{ entry.name }}</a>
                    {% endif %}
                </div>
                {% endfor %}
            </div>
        </div>
        <div class="card">
            <h3 style="margin:0 0 8px;">File Preview</h3>
            <div class="pane-scroll" id="run-file-preview-scroll">
                <div id="run-file-preview" class="meta">‰ªéÂ∑¶‰æßÈÄâÊã©Êñá‰ª∂„ÄÇ</div>
            </div>
        </div>
    </div>

    <div class="row">
        <div class="card">
            <h3 style="margin:0 0 8px;">ÂØπËØùÂå∫ÔºàFCMPÔºâ</h3>
            <div id="stdout-log" class="conversation-window"></div>
        </div>
        <div class="card">
            <h3 style="margin:0 0 8px;">raw_ref ÂõûË∑≥È¢ÑËßà</h3>
            <pre id="raw-ref-preview" class="raw-ref-window"></pre>
        </div>
    </div>

    <div class="card">
        <div class="meta" style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <strong>Attempt:</strong>
            <button id="attempt-prev-btn" type="button">‚Üê</button>
            <span id="attempt-label">-</span>
            <button id="attempt-next-btn" type="button">‚Üí</button>
        </div>
    </div>

    <div class="row three">
        <div class="card">
            <h3 style="margin:0 0 8px;">FCMP Audit Stream</h3>
            <pre id="fcmp-audit-log" class="protocol-window"></pre>
        </div>
        <div class="card">
            <h3 style="margin:0 0 8px;">RASP Audit Stream</h3>
            <pre id="rasp-audit-log" class="protocol-window"></pre>
        </div>
        <div class="card">
            <h3 style="margin:0 0 8px;">Orchestrator Audit Stream</h3>
            <pre id="orchestrator-audit-log" class="protocol-window"></pre>
        </div>
    </div>

    <div class="row">
        <div class="card">
            <h3 style="margin:0 0 8px;">Raw stderr</h3>
            <pre id="stderr-log" class="stderr-window"></pre>
        </div>
        <div class="card">
            <h3 style="margin:0 0 8px;">Run Actions</h3>
            <button id="cancel-run-btn" class="danger" type="button">Cancel Run</button>
        </div>
    </div>
</div>

<script>
(function () {
    const requestId = {{ detail.request_id | tojson }};
    const statusEl = document.getElementById("run-status");
    const updatedAtEl = document.getElementById("run-updated-at");
    const pendingIdEl = document.getElementById("run-pending-id");
    const interactionCountEl = document.getElementById("run-interaction-count");
    const stdoutEl = document.getElementById("stdout-log");
    const stderrEl = document.getElementById("stderr-log");
    const rawRefPreviewEl = document.getElementById("raw-ref-preview");
    const fcmpAuditEl = document.getElementById("fcmp-audit-log");
    const raspAuditEl = document.getElementById("rasp-audit-log");
    const orchestratorAuditEl = document.getElementById("orchestrator-audit-log");
    const attemptPrevBtn = document.getElementById("attempt-prev-btn");
    const attemptNextBtn = document.getElementById("attempt-next-btn");
    const attemptLabelEl = document.getElementById("attempt-label");
    const cancelBtn = document.getElementById("cancel-run-btn");

    const terminalStatuses = new Set(["succeeded", "failed", "canceled"]);
    const renderedChatSeq = new Set();
    const auditCursor = { fcmp: 0, rasp: 0, orchestrator: 0 };
    const availableAttempts = [];

    let cursor = 0;
    let source = null;
    let reconnectTimer = null;
    let terminal = terminalStatuses.has(statusEl.textContent || "");
    let currentAttempt = 1;

    function appendLog(target, chunk) {
        if (!chunk) return;
        target.textContent += chunk;
        target.scrollTop = target.scrollHeight;
    }

    function appendProtocolRows(target, rows) {
        if (!Array.isArray(rows) || !rows.length) return;
        for (const row of rows) {
            appendLog(target, `${JSON.stringify(row, null, 2)}\n`);
        }
    }

    function extractRawRef(event) {
        const candidate = event && event.raw_ref;
        if (!candidate || typeof candidate !== "object") return null;
        if (typeof candidate.stream !== "string") return null;
        const from = Number(candidate.byte_from || 0);
        const to = Number(candidate.byte_to || 0);
        if (!Number.isFinite(from) || !Number.isFinite(to) || to < from) return null;
        const attemptNumber = Number(candidate.attempt_number || currentAttempt);
        return {
            stream: candidate.stream,
            byte_from: Math.max(0, Math.floor(from)),
            byte_to: Math.max(0, Math.floor(to)),
            attempt_number: Number.isFinite(attemptNumber) && attemptNumber > 0
                ? Math.floor(attemptNumber)
                : currentAttempt,
        };
    }

    async function previewRawRef(rawRef) {
        if (!rawRef) return;
        const query = new URLSearchParams({
            stream: rawRef.stream,
            byte_from: String(rawRef.byte_from),
            byte_to: String(rawRef.byte_to),
            attempt: String(rawRef.attempt_number || currentAttempt),
        });
        rawRefPreviewEl.textContent = `loading ${rawRef.stream}[${rawRef.byte_from}, ${rawRef.byte_to}] ...`;
        const res = await fetch(`/v1/management/runs/${requestId}/logs/range?${query.toString()}`);
        if (!res.ok) {
            rawRefPreviewEl.textContent = `raw_ref preview unavailable: HTTP ${res.status}`;
            return;
        }
        const payload = await res.json();
        rawRefPreviewEl.textContent = `${payload.stream}[${payload.byte_from}, ${payload.byte_to}]\n\n${payload.chunk || ""}`;
    }

    function eventAttempt(event) {
        const attemptObj = event && event.meta && event.meta.attempt;
        const attempt = Number(attemptObj || event?.data?.attempt_number || 0);
        return Number.isFinite(attempt) && attempt > 0 ? Math.floor(attempt) : currentAttempt;
    }

    function appendChatEvent(role, text, event, rawRef) {
        const seq = typeof event?.seq === "number" ? event.seq : 0;
        const localSeqObj = event && event.meta && event.meta.local_seq;
        const localSeq = Number(localSeqObj || 0);
        const displaySeq = Number.isFinite(localSeq) && localSeq > 0 ? Math.floor(localSeq) : seq;
        const attempt = eventAttempt(event);
        const key = `${attempt}:${seq}:${event?.type || ""}:${role}:${text || ""}`;
        if (renderedChatSeq.has(key)) return;
        renderedChatSeq.add(key);
        const item = document.createElement("div");
        item.className = `chat-item${role === "system" ? " system" : role === "user" ? " user" : ""}`;
        const header = document.createElement("div");
        const title = document.createElement("strong");
        title.textContent = role === "assistant" ? "Agent" : role === "user" ? "User" : "System";
        header.appendChild(title);
        item.appendChild(header);

        const pre = document.createElement("pre");
        pre.textContent = text || "";
        item.appendChild(pre);
        const meta = document.createElement("div");
        meta.className = "meta";
        meta.textContent = `attempt ${attempt}${displaySeq ? ` ¬∑ seq ${displaySeq}` : ""}`;
        item.appendChild(meta);

        if (rawRef) {
            const refMeta = document.createElement("div");
            refMeta.className = "meta";
            const btn = document.createElement("button");
            btn.className = "link-btn";
            btn.type = "button";
            btn.textContent = `raw_ref a${rawRef.attempt_number} ${rawRef.stream}[${rawRef.byte_from}, ${rawRef.byte_to}]`;
            btn.addEventListener("click", () => previewRawRef(rawRef));
            refMeta.appendChild(btn);
            item.appendChild(refMeta);
        }
        stdoutEl.appendChild(item);
        stdoutEl.scrollTop = stdoutEl.scrollHeight;
    }

    function closeStream() {
        if (source) {
            source.close();
            source = null;
        }
    }

    function stripAskUserBlocks(text) {
        if (typeof text !== "string" || !text.trim()) return "";
        let normalized = text;
        normalized = normalized.replace(
            /<ASK_USER_YAML>\s*[\s\S]*?\s*<\/ASK_USER_YAML>/gim,
            "\n",
        );
        normalized = normalized.replace(
            /```(?:ask_user_yaml|ask-user-yaml)\s*[\s\S]*?```/gim,
            "\n",
        );
        normalized = normalized.replace(/\n{3,}/g, "\n\n");
        return normalized.trim();
    }

    function updateStatus(payload) {
        if (!payload || typeof payload !== "object") return;
        if (typeof payload.status === "string" && payload.status) {
            statusEl.textContent = payload.status;
            terminal = terminalStatuses.has(payload.status);
            if (terminal) {
                closeStream();
            }
        }
        if (typeof payload.updated_at === "string" && payload.updated_at) {
            updatedAtEl.textContent = payload.updated_at;
        }
        if (payload.pending_interaction_id !== undefined) {
            pendingIdEl.textContent = payload.pending_interaction_id === null ? "-" : String(payload.pending_interaction_id);
        }
        if (payload.interaction_count !== undefined && payload.interaction_count !== null) {
            interactionCountEl.textContent = String(payload.interaction_count);
        }
    }

    async function refreshState() {
        const res = await fetch(`/v1/management/runs/${requestId}`);
        if (!res.ok) return;
        const data = await res.json();
        updateStatus(data);
    }

    function updateAttemptPager() {
        if (!availableAttempts.length) {
            attemptLabelEl.textContent = "-";
            attemptPrevBtn.disabled = true;
            attemptNextBtn.disabled = true;
            return;
        }
        const idx = availableAttempts.indexOf(currentAttempt);
        attemptLabelEl.textContent = `${currentAttempt} / ${availableAttempts[availableAttempts.length - 1]}`;
        attemptPrevBtn.disabled = idx <= 0;
        attemptNextBtn.disabled = idx < 0 || idx >= availableAttempts.length - 1;
    }

    async function fetchProtocolHistory(streamName, attempt, fromSeq = null) {
        const query = new URLSearchParams({ stream: streamName });
        if (attempt !== null && attempt !== undefined) {
            query.set("attempt", String(attempt));
        }
        if (typeof fromSeq === "number" && fromSeq > 0) {
            query.set("from_seq", String(fromSeq));
        }
        const res = await fetch(`/v1/management/runs/${requestId}/protocol/history?${query.toString()}`);
        if (!res.ok) {
            return null;
        }
        return await res.json();
    }

    function updateAvailableAttempts(candidates) {
        if (!Array.isArray(candidates) || !candidates.length) {
            if (!availableAttempts.length) {
                availableAttempts.push(currentAttempt);
            }
            return;
        }
        availableAttempts.length = 0;
        for (const value of candidates) {
            const attempt = Number(value);
            if (!Number.isFinite(attempt) || attempt <= 0) continue;
            availableAttempts.push(Math.floor(attempt));
        }
        availableAttempts.sort((a, b) => a - b);
    }

    async function refreshProtocolHistory(streamName, targetEl) {
        const fromSeq = auditCursor[streamName] > 0 ? auditCursor[streamName] + 1 : null;
        const payload = await fetchProtocolHistory(streamName, currentAttempt, fromSeq);
        if (!payload) return;
        const rows = Array.isArray(payload.events) ? payload.events : [];
        if (Array.isArray(payload.available_attempts)) {
            updateAvailableAttempts(payload.available_attempts);
            updateAttemptPager();
        }
        for (const row of rows) {
            const seq = Number(row && row.seq);
            if (Number.isFinite(seq)) {
                auditCursor[streamName] = Math.max(auditCursor[streamName], Math.floor(seq));
            }
        }
        appendProtocolRows(targetEl, rows);
    }

    async function loadProtocolPanel(streamName, targetEl) {
        targetEl.textContent = "";
        auditCursor[streamName] = 0;
        const payload = await fetchProtocolHistory(streamName, currentAttempt);
        if (!payload) return;
        if (Array.isArray(payload.available_attempts)) {
            updateAvailableAttempts(payload.available_attempts);
            updateAttemptPager();
        }
        const rows = Array.isArray(payload.events) ? payload.events : [];
        appendProtocolRows(targetEl, rows);
        for (const row of rows) {
            const seq = Number(row && row.seq);
            if (Number.isFinite(seq)) {
                auditCursor[streamName] = Math.max(auditCursor[streamName], Math.floor(seq));
            }
        }
    }

    async function loadStderrForAttempt() {
        const query = new URLSearchParams({
            stream: "stderr",
            byte_from: "0",
            byte_to: String(4 * 1024 * 1024),
            attempt: String(currentAttempt),
        });
        const res = await fetch(`/v1/management/runs/${requestId}/logs/range?${query.toString()}`);
        if (!res.ok) {
            stderrEl.textContent = "";
            return;
        }
        const payload = await res.json();
        stderrEl.textContent = payload.chunk || "";
    }

    async function loadConversationHistory() {
        stdoutEl.textContent = "";
        renderedChatSeq.clear();
        for (const attempt of availableAttempts) {
            const payload = await fetchProtocolHistory("fcmp", attempt);
            if (!payload) continue;
            const events = Array.isArray(payload.events) ? payload.events : [];
            for (const event of events) {
                const type = typeof event.type === "string" ? event.type : "";
                const rawRef = extractRawRef(event);
                if (type === "assistant.message.final") {
                    const text = stripAskUserBlocks(event.data ? event.data.text : "");
                    if (text) {
                        appendChatEvent("assistant", text, event, rawRef);
                    }
                } else if (type === "user.input.required") {
                    // Control event only; avoid duplicate chat content.
                } else if (type === "interaction.reply.accepted") {
                    const preview = event.data && typeof event.data.response_preview === "string"
                        ? event.data.response_preview.trim()
                        : "";
                    if (preview) {
                        appendChatEvent("user", preview, event, rawRef);
                    } else {
                        appendChatEvent("system", "Reply accepted, run resumed.", event, rawRef);
                    }
                } else if (type === "interaction.auto_decide.timeout") {
                    appendChatEvent("system", "Timeout auto decision applied.", event, rawRef);
                } else if (type === "conversation.completed") {
                    appendChatEvent("system", "‰ªªÂä°Â∑≤ÂÆåÊàê„ÄÇ", event, rawRef);
                } else if (type === "conversation.failed") {
                    appendChatEvent("system", "‰ªªÂä°ÊâßË°åÂ§±Ë¥•„ÄÇ", event, rawRef);
                } else if (type === "conversation.state.changed") {
                    updateStatus({
                        status: event.data && event.data.to ? event.data.to : undefined,
                        updated_at: event.data && event.data.updated_at ? event.data.updated_at : undefined,
                        pending_interaction_id: event.data && event.data.pending_interaction_id !== undefined
                            ? event.data.pending_interaction_id
                            : undefined,
                    });
                }
            }
            if (attempt === currentAttempt) {
                for (const event of events) {
                    const seqObj = event && event.seq;
                    if (typeof seqObj === "number") {
                        cursor = Math.max(cursor, seqObj);
                    }
                }
            }
        }
    }

    async function bootstrapAttemptsAndPanels() {
        const latestPayload = await fetchProtocolHistory("fcmp", null);
        if (!latestPayload) {
            currentAttempt = 1;
            updateAvailableAttempts([1]);
            updateAttemptPager();
            return;
        }
        updateAvailableAttempts(latestPayload.available_attempts);
        const selectedAttempt = Number(latestPayload.attempt || 0);
        if (Number.isFinite(selectedAttempt) && selectedAttempt > 0) {
            currentAttempt = Math.floor(selectedAttempt);
        } else if (availableAttempts.length) {
            currentAttempt = availableAttempts[availableAttempts.length - 1];
        } else {
            currentAttempt = 1;
        }
        updateAttemptPager();
        await loadConversationHistory();
        await loadProtocolPanel("fcmp", fcmpAuditEl);
        await loadProtocolPanel("rasp", raspAuditEl);
        await loadProtocolPanel("orchestrator", orchestratorAuditEl);
        await loadStderrForAttempt();
    }

    function scheduleReconnect() {
        if (terminal) return;
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
        }
        reconnectTimer = setTimeout(() => connectEvents(), 1000);
    }

    function connectEvents() {
        if (terminal) return;
        closeStream();
        source = new EventSource(`/v1/management/runs/${requestId}/events?cursor=${cursor}`);

        source.addEventListener("snapshot", (evt) => {
            const data = JSON.parse(evt.data || "{}");
            if (typeof data.cursor === "number") {
                cursor = Math.max(cursor, data.cursor);
            }
            updateStatus(data);
        });

        source.addEventListener("chat_event", (evt) => {
            const data = JSON.parse(evt.data || "{}");
            const type = typeof data.type === "string" ? data.type : "";
            const seq = typeof data.seq === "number" ? data.seq : 0;
            const rawRef = extractRawRef(data);
            if (seq > 0) {
                cursor = Math.max(cursor, seq);
            }
            if (type === "conversation.state.changed") {
                updateStatus({
                    status: data.data && data.data.to ? data.data.to : undefined,
                    updated_at: data.data && data.data.updated_at ? data.data.updated_at : undefined,
                    pending_interaction_id: data.data && data.data.pending_interaction_id !== undefined
                        ? data.data.pending_interaction_id
                        : undefined,
                });
                return;
            }
            if (type === "assistant.message.final") {
                const text = stripAskUserBlocks(data.data ? data.data.text : "");
                if (text) {
                    appendChatEvent("assistant", text, data, rawRef);
                }
                return;
            }
            if (type === "user.input.required") {
                // Control event only; avoid duplicate chat content.
                return;
            }
            if (type === "interaction.reply.accepted") {
                const preview = data.data && typeof data.data.response_preview === "string"
                    ? data.data.response_preview.trim()
                    : "";
                if (preview) {
                    appendChatEvent("user", preview, data, rawRef);
                } else {
                    appendChatEvent("system", "Reply accepted, run resumed.", data, rawRef);
                }
                return;
            }
            if (type === "interaction.auto_decide.timeout") {
                appendChatEvent("system", "Timeout auto decision applied.", data, rawRef);
                return;
            }
            if (type === "conversation.completed") {
                appendChatEvent("system", "‰ªªÂä°Â∑≤ÂÆåÊàê„ÄÇ", data, rawRef);
                updateStatus({ status: "succeeded" });
                return;
            }
            if (type === "conversation.failed") {
                appendChatEvent("system", "‰ªªÂä°ÊâßË°åÂ§±Ë¥•„ÄÇ", data, rawRef);
                updateStatus({ status: "failed" });
                return;
            }
            if (type === "raw.stderr") {
                appendLog(stderrEl, `${data.data && data.data.line ? data.data.line : ""}\n`);
            }
        });

        source.onerror = () => {
            closeStream();
            if (!terminal && statusEl.textContent !== "waiting_user") {
                scheduleReconnect();
            }
        };
    }

    cancelBtn.addEventListener("click", async () => {
        cancelBtn.disabled = true;
        await fetch(`/v1/management/runs/${requestId}/cancel`, { method: "POST" });
        await refreshState();
        closeStream();
    });

    attemptPrevBtn.addEventListener("click", async () => {
        const idx = availableAttempts.indexOf(currentAttempt);
        if (idx <= 0) return;
        currentAttempt = availableAttempts[idx - 1];
        updateAttemptPager();
        await loadProtocolPanel("fcmp", fcmpAuditEl);
        await loadProtocolPanel("rasp", raspAuditEl);
        await loadProtocolPanel("orchestrator", orchestratorAuditEl);
        await loadStderrForAttempt();
    });

    attemptNextBtn.addEventListener("click", async () => {
        const idx = availableAttempts.indexOf(currentAttempt);
        if (idx < 0 || idx >= availableAttempts.length - 1) return;
        currentAttempt = availableAttempts[idx + 1];
        updateAttemptPager();
        await loadProtocolPanel("fcmp", fcmpAuditEl);
        await loadProtocolPanel("rasp", raspAuditEl);
        await loadProtocolPanel("orchestrator", orchestratorAuditEl);
        await loadStderrForAttempt();
    });

    setInterval(() => {
        loadStderrForAttempt().catch(() => {});
        refreshProtocolHistory("fcmp", fcmpAuditEl).catch(() => {});
        refreshProtocolHistory("rasp", raspAuditEl).catch(() => {});
        refreshProtocolHistory("orchestrator", orchestratorAuditEl).catch(() => {});
    }, 3000);

    bootstrapAttemptsAndPanels().catch(() => {});

    if (!terminal) {
        connectEvents();
    }
})();
</script>
</body>
</html>
